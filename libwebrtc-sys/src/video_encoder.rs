use cxx::{CxxVector, UniquePtr};

use crate::ffi::{ArcasCxxVideoFrameType, ArcasEncodedImageCallback};

type EncodedImageCallback = dyn Fn(
    UniquePtr<crate::ffi::ArcasCxxEncodedImage>,
    UniquePtr<crate::ffi::ArcasCodecSpecificInfo>,
);

pub struct EncodedImageCallbackHandler {
    on_dropped: Box<dyn Fn(crate::ffi::ArcasVideoEncoderDropReason)>,
    on_encoded_image: Box<EncodedImageCallback>,
}

impl EncodedImageCallbackHandler {
    pub fn new(
        on_dropped: Box<dyn Fn(crate::ffi::ArcasVideoEncoderDropReason)>,
        on_encoded_image: Box<EncodedImageCallback>,
    ) -> Self {
        Self {
            on_dropped,
            on_encoded_image,
        }
    }

    pub fn trigger_encoded_image(
        &self,
        image: UniquePtr<crate::ffi::ArcasCxxEncodedImage>,
        codec_info: UniquePtr<crate::ffi::ArcasCodecSpecificInfo>,
    ) {
        (self.on_encoded_image)(image, codec_info);
    }

    pub fn trigger_dropped(&self, reason: crate::ffi::ArcasVideoEncoderDropReason) {
        (self.on_dropped)(reason);
    }
}

pub trait VideoEncoderImpl {
    /// Initialize the encoder with the information from the codecSettings
    ///
    /// Input:
    ///          - codec_settings    : Codec settings
    ///          - settings          : Settings affecting the encoding itself.
    /// Input for deprecated version:
    ///          - number_of_cores   : Number of cores available for the encoder
    ///          - max_payload_size  : The maximum size each payload is allowed
    ///                                to have. Usually MTU - overhead.
    ///
    /// Return value                  : Set bit rate if OK
    ///                                 <0 - Errors:
    ///                                  WEBRTC_VIDEO_CODEC_ERR_PARAMETER
    ///                                  WEBRTC_VIDEO_CODEC_ERR_SIZE
    ///                                  WEBRTC_VIDEO_CODEC_MEMORY
    ///                                  WEBRTC_VIDEO_CODEC_ERROR
    unsafe fn init_encode(
        &self,
        codec_settings: *const crate::ffi::ArcasCxxVideoCodec,
        number_of_cores: i32,
        max_payload_size: usize,
    ) -> i32;

    /// Register an encode complete callback object.
    ///
    /// Input:
    ///          - callback         : Callback object which handles encoded images.
    ///
    /// Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    fn register_encode_complete_callback(
        &self,
        callback: UniquePtr<ArcasEncodedImageCallback>,
    ) -> i32;

    /// Free encoder memory.
    /// Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    fn release(&self) -> i32;

    /// Encode an image (as a part of a video stream). The encoded image
    /// will be returned to the user through the encode complete callback.
    ///
    /// Input:
    ///          - frame             : Image to be encoded
    ///          - frame_types       : Frame type to be generated by the encoder.
    ///
    /// Return value                 : WEBRTC_VIDEO_CODEC_OK if OK
    ///                                <0 - Errors:
    ///                                  WEBRTC_VIDEO_CODEC_ERR_PARAMETER
    ///                                  WEBRTC_VIDEO_CODEC_MEMORY
    ///                                  WEBRTC_VIDEO_CODEC_ERROR
    fn encode(
        &self,
        frame: &crate::ffi::ArcasCxxVideoFrame,
        frame_types: *const CxxVector<ArcasCxxVideoFrameType>,
    ) -> i32;

    /// Sets rate control parameters: bitrate, framerate, etc. These settings are
    /// instantaneous (i.e. not moving averages) and should apply from now until
    /// the next call to SetRates().
    fn set_rates(&self, parameters: UniquePtr<crate::ffi::ArcasVideoEncoderRateControlParameters>);

    /// Inform the encoder when the packet loss rate changes.
    ///
    /// Input:   - packet_loss_rate  : The packet loss rate (0.0 to 1.0).
    fn on_packet_loss_rate_update(&self, packet_loss_rate: f32);

    /// Inform the encoder when the round trip time changes.
    ///
    /// Input:   - rtt_ms            : The new RTT, in milliseconds.
    fn on_rtt_update(&self, rtt: i64);

    /// Called when a loss notification is received.
    fn on_loss_notification(
        &self,
        loss_notification: crate::ffi::ArcasVideoEncoderLossNotification,
    );

    /// Returns meta-data about the encoder, such as implementation name.
    /// The output of this method may change during runtime. For instance if a
    /// hardware encoder fails, it may fall back to doing software encoding using
    /// an implementation with different characteristics.
    fn get_encoder_info(&self) -> crate::ffi::ArcasVideoEncoderInfo;
}

pub struct VideoEncoderProxy {
    // Obviously for an encoder pipeline dynamic dispatch is not ideal.
    // We likely need to revisit this and write custom encoders only in C++.
    api: Box<dyn VideoEncoderImpl>,
}

impl VideoEncoderProxy {
    pub fn new(api: Box<dyn VideoEncoderImpl>) -> Self {
        Self { api }
    }

    pub unsafe fn init_encode(
        &self,
        codec_settings: *const crate::ffi::ArcasCxxVideoCodec,
        number_of_cores: i32,
        max_payload_size: usize,
    ) -> i32 {
        self.api
            .init_encode(codec_settings, number_of_cores, max_payload_size)
    }

    pub fn register_encode_complete_callback(
        &self,
        callback: UniquePtr<ArcasEncodedImageCallback>,
    ) -> i32 {
        self.api.register_encode_complete_callback(callback)
    }

    pub fn release(&self) -> i32 {
        self.api.release()
    }

    pub fn encode(
        &self,
        frame: &crate::ffi::ArcasCxxVideoFrame,
        frame_types: *const CxxVector<ArcasCxxVideoFrameType>,
    ) -> i32 {
        self.api.encode(frame, frame_types)
    }

    pub fn get_encoder_info(&self) -> crate::ffi::ArcasVideoEncoderInfo {
        self.api.get_encoder_info()
    }

    pub fn set_rates(
        &self,
        parameters: UniquePtr<crate::ffi::ArcasVideoEncoderRateControlParameters>,
    ) {
        self.api.set_rates(parameters)
    }

    pub fn on_packet_loss_rate_update(&self, packet_loss_rate: f32) {
        self.api.on_packet_loss_rate_update(packet_loss_rate)
    }

    pub fn on_rtt_update(&self, rtt: i64) {
        self.api.on_rtt_update(rtt)
    }

    pub fn on_loss_notification(
        &self,
        loss_notification: crate::ffi::ArcasVideoEncoderLossNotification,
    ) {
        self.api.on_loss_notification(loss_notification)
    }
}
